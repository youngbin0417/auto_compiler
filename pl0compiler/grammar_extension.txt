// 새로운 문법 규칙 정의\n%type <number> Dcl VarDcl Ident_list ProcHead ParamList ParamDeclList\n\nDcl: ConstDcl VarDcl ProcDef_list { $$=$2; } ;\n\nProcDef: ProcHead { SetBlock(); } Block ';' { Emit(\"RET\", 0); ResetBlock(); }  ;\n\nProcHead: TPROC ID {\n    Enter($2, PROC, level, cdx, 0, 0); \n    EmitPname($2); \n}\n    | TPROC ID '(' ParamList ')' {\n    Enter($2, PROC, level, cdx, 0, 0); \n    EmitPname($2); \n    // 매개변수 개수를 심볼 테이블에 저장\n    int procIndex = avail - 1; // 방금 추가한 PROCEDURE의 인덱스\n    table[procIndex].param_count = $4; // ParamList에서 반환된 매개변수 개수 저장\n} ;\n\n// 매개변수 목록 문법\nParamList: ParamDeclList { $$ = $1; }\n    | { $$ = 0; } ;  // 매개변수가 없는 경우\n\nParamDeclList: ParamDeclList ',' ID {\n    // 매개변수를 심볼 테이블에 등록\n    Enter($3, VAR, level+1, $1, 0, 0); // level+1로 설정하여 PROCEDURE 내부의 레벨로 지정\n    $$ = $1 + 1; // 매개변수 개수 증가\n}\n    | ID {\n    // 첫 번째 매개변수를 심볼 테이블에 등록\n    Enter($1, VAR, level+1, 3, 0, 0); // 첫 매개변수의 오프셋은 3\n    $$ = 1; // 매개변수 개수 1로 초기화\n} ;\n\nStatement: ID '[' Expression ']' {\n    if (Lookup($1, VAR)) {\n        // 인덱스 Expression(`i`)이 이미 평가되어 스택에 푸시됨\n        // 배열의 기본 주소를 로드하고, 인덱스를 더함\n        Emit1(\"LDA\", Lda, LDiff, OFFSET); // base address 푸시 (100)\n        Emit(\"ADD\", 2); // base + i 계산, 스택에 푸시\n    }\n} ASSIGN Expression {\n    if (Lookup($1, VAR)) {\n        // 할당할 값 Expression(`expr`)이 이미 평가되어 스택에 푸시됨\n        Emit1(\"STI\", Sti, 0, 0);           // `expr` 값을 `base + i` 주소에 저장\n    }\n}\n    | ID ASSIGN Expression { Lookup($1, VAR); Emit1(\"STO\", Sto, LDiff, OFFSET); }\n    | TCALL ID {\n        Lookup($2, PROC); \n        Emit2(\"CAL\", LDiff, $2);\n    }\n    | TCALL ID '(' ExpressionList ')' {\n        // 함수 호출 시 매개변수 전달\n        Lookup($2, PROC);\n        // 매개변수 개수 확인 및 코드 생성\n        Emit2(\"CAL\", LDiff, $2);\n    }\n    | TBEGIN Statement_list TEND\n    | TIF Condition { Emit3(\"JPC\", Jpc, $<number>$=GenLab(Lname)); }\n        TTHEN Statement { EmitLab($<number>3); }\n    | TWHILE { EmitLab1($<number>$=GenLab(Lname) ); }\n        Condition { Emit3(\"JPC\", Jpc, $<number>$=GenLab(Lname)); }\n        TDO Statement { Emit3(\"JMP\", Jmp, $<number>2); EmitLab($<number>4); }\n    | TWRITE ID '[' Expression ']' {\n        if (Lookup($2, VAR)) {\n            Emit1(\"LDA\", Lda, LDiff, OFFSET);\n            Emit(\"ADD\", 2);\n            Emit1(\"LDI\", Ldi, 0, 0);\n            EmitOut(\"OUT\", Out);\n        } else {\n            fprintf(stderr, \"Error: '%s' is not declared as an array.\\n\", $2);\n        }\n    }\n    | TWRITE ID { Lookup($2,VAR); Emit1(\"LOD\", Lod, LDiff, OFFSET); EmitOut(\"OUT\",Out); }\n    | error { yyerrok; }\n    | ;\n\n// 표현식 목록 문법 (함수 호출 시 사용)\nExpressionList: ExpressionList ',' Expression { $$ = $1 + 1; }\n    | Expression { $$ = 1; } ;